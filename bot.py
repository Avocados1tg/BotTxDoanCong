import logging
import random
import os
import sqlite3
import asyncio
import csv
import io
from datetime import datetime, timedelta
from collections import defaultdict
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, InputFile
from telegram.ext import Application, CommandHandler, CallbackQueryHandler, MessageHandler, filters, ContextTypes

TOKEN = os.getenv('TELEGRAM_BOT_TOKEN')
ADMIN_ID = int(os.getenv('ADMIN_ID', '0'))  # Th√™m env cho admin, 0 n·∫øu kh√¥ng d√πng

if not TOKEN:
    print("L·ªói: Kh√¥ng t√¨m th·∫•y TELEGRAM_BOT_TOKEN. ƒê·∫∑t v√†o Railway!")
    exit(1)

# DB setup (m·ªü r·ªông cho shop, streak)
DB_FILE = 'taixiu.db'
conn = sqlite3.connect(DB_FILE, check_same_thread=False)
cursor = conn.cursor()
cursor.execute('''CREATE TABLE IF NOT EXISTS users (user_id INTEGER PRIMARY KEY, wins INTEGER DEFAULT 0, losses INTEGER DEFAULT 0, balance INTEGER DEFAULT 100, last_bonus DATE DEFAULT NULL, streak INTEGER DEFAULT 0, skin TEXT DEFAULT 'standard', last_streak_update TIMESTAMP DEFAULT CURRENT_TIMESTAMP)''')
cursor.execute('''CREATE TABLE IF NOT EXISTS history (user_id INTEGER, entry TEXT, timestamp DATETIME DEFAULT CURRENT_TIMESTAMP)''')
cursor.execute('''CREATE TABLE IF NOT EXISTS group_votes (group_id INTEGER, total INTEGER, votes_tai INTEGER DEFAULT 0, votes_xiu INTEGER DEFAULT 0, timestamp DATETIME DEFAULT CURRENT_TIMESTAMP)''')
cursor.execute('''CREATE TABLE IF NOT EXISTS shop_items (user_id INTEGER, item_name TEXT, purchased TIMESTAMP DEFAULT CURRENT_TIMESTAMP)''')  # Cho shop
conn.commit()

def get_user_data(user_id):
    cursor.execute("SELECT * FROM users WHERE user_id = ?", (user_id,))
    row = cursor.fetchone()
    if row:
        return {'wins': row[1], 'losses': row[2], 'balance': row[3], 'last_bonus': row[4], 'streak': row[5], 'skin': row[6], 'last_streak_update': row[7]}
    else:
        cursor.execute("INSERT INTO users (user_id, wins, losses, balance, last_bonus, streak, skin, last_streak_update) VALUES (?, 0, 0, 100, NULL, 0, 'standard', CURRENT_TIMESTAMP)", (user_id,))
        conn.commit()
        return {'wins': 0, 'losses': 0, 'balance': 100, 'last_bonus': None, 'streak': 0, 'skin': 'standard', 'last_streak_update': datetime.now()}

def update_user_data(user_id, data):
    cursor.execute("UPDATE users SET wins = ?, losses = ?, balance = ?, last_bonus = ?, streak = ?, skin = ?, last_streak_update = ? WHERE user_id = ?", (data['wins'], data['losses'], data['balance'], data['last_bonus'], data['streak'], data['skin'], data['last_streak_update'], user_id))
    conn.commit()

def add_history(user_id, entry):
    cursor.execute("INSERT INTO history (user_id, entry) VALUES (?, ?)", (user_id, entry))
    conn.commit()

def get_history(user_id, limit=5):
    cursor.execute("SELECT entry FROM history WHERE user_id = ? ORDER BY timestamp DESC LIMIT ?", (user_id, limit))
    return [row[0] for row in cursor.fetchall()]

def get_top_users(limit=10):
    cursor.execute("SELECT user_id, wins FROM users ORDER BY wins DESC LIMIT ?", (limit,))
    return cursor.fetchall()

def can_claim_bonus(user_id):
    data = get_user_data(user_id)
    if not data['last_bonus']:
        return True
    last_date = datetime.strptime(data['last_bonus'], '%Y-%m-%d').date()
    today = datetime.now().date()
    return last_date < today

def claim_bonus(user_id):
    bonus = random.randint(10, 50)
    data = get_user_data(user_id)
    data['balance'] += bonus
    data['last_bonus'] = datetime.now().date().strftime('%Y-%m-%d')
    update_user_data(user_id, data)
    return bonus

def update_streak(user_id, win):
    data = get_user_data(user_id)
    if win:
        data['streak'] += 1
        if data['streak'] % 3 == 0:
            data['balance'] += 50
            add_history(user_id, f"Streak bonus! +50 ƒëi·ªÉm (streak {data['streak']})")
    else:
        data['streak'] = 0
    data['last_streak_update'] = datetime.now()
    update_user_data(user_id, data)

def buy_item(user_id, item_name, price):
    data = get_user_data(user_id)
    if data['balance'] < price:
        return False, "Kh√¥ng ƒë·ªß ƒëi·ªÉm!"
    data['balance'] -= price
    cursor.execute("INSERT INTO shop_items (user_id, item_name) VALUES (?, ?)", (user_id, item_name))
    conn.commit()
    data['skin'] = item_name
    update_user_data(user_id, data)
    return True, f"Mua th√†nh c√¥ng! Skin m·ªõi: {item_name}"

def get_user_items(user_id):
    cursor.execute("SELECT item_name FROM shop_items WHERE user_id = ?", (user_id,))
    return [row[0] for row in cursor.fetchall()]

# C√°c function kh√°c gi·ªØ nguy√™n (add_group_roll, vote_group, get_group_vote)

logging.basicConfig(level=logging.INFO)

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    get_user_data(user_id)
    keyboard = get_main_keyboard()
    welcome_msg = """
üî• **Bot T√†i X·ªâu Full Max!** üé≤

Ch√†o anh! C√¢n b·∫±ng: **100 ƒëi·ªÉm gi·∫£** üí∞
T√†i 11-18, X·ªâu 3-10. Streak, shop, AI chat, export...
Ch·ªçn n√∫t ch∆°i üòé
    """
    await update.message.reply_text(welcome_msg, parse_mode='Markdown', reply_markup=keyboard)

def get_main_keyboard():
    keyboard = [
        [InlineKeyboardButton("üé≤ Ch∆°i T√†i X·ªâu", callback_data='play')],
        [InlineKeyboardButton("üõí Shop Skin", callback_data='shop')],
        [InlineKeyboardButton("ü§ñ Chat AI", callback_data='ai_chat')],
        [InlineKeyboardButton("üë§ Profile", callback_data='profile')],
        [InlineKeyboardButton("‚öîÔ∏è Th√°ch ƒë·∫•u b·∫°n", callback_data='challenge')],
        [InlineKeyboardButton("üéÅ Daily Bonus", callback_data='bonus')],
        [InlineKeyboardButton("üìä ƒêi·ªÉm s·ªë", callback_data='score')],
        [InlineKeyboardButton("üìú L·ªãch s·ª≠", callback_data='history')],
        [InlineKeyboardButton("üèÜ Top 10", callback_data='top')],
        [InlineKeyboardButton("üåê Roll Group", callback_data='group_roll')],
        [InlineKeyboardButton("üì§ Export CSV", callback_data='export')],
        [InlineKeyboardButton("‚ÑπÔ∏è H∆∞·ªõng d·∫´n", callback_data='help')],
        [InlineKeyboardButton("üîÑ Reset", callback_data='reset')]
    ]
    return InlineKeyboardMarkup(keyboard)

async def button_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    user_id = query.from_user.id
    chat_id = query.message.chat_id

    if query.data == 'play':
        keyboard = [
            [InlineKeyboardButton("üíµ 10 ƒëi·ªÉm", callback_data='bet_10'), InlineKeyboardButton("üíé 20 ƒëi·ªÉm", callback_data='bet_20')],
            [InlineKeyboardButton("üí∞ 50 ƒëi·ªÉm", callback_data='bet_50')],
            [InlineKeyboardButton("üí≥ Nh·∫≠p ti·ªÅn t√πy ch·ªânh", callback_data='custom_bet')],
            [InlineKeyboardButton("üîô Menu", callback_data='menu')]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await context.bot.send_message(chat_id=chat_id, text='üí∞ **Ch·ªçn m·ª©c c∆∞·ª£c:**\n*(Ho·∫∑c nh·∫≠p t√πy ch·ªânh!)* üé∞', parse_mode='Markdown', reply_markup=reply_markup)
        return

    elif query.data.startswith('bet_'):
        bet = int(query.data.split('_')[1])
        data = get_user_data(user_id)
        if data['balance'] < bet or bet < 1 or bet > data['balance']:
            keyboard = get_menu_keyboard()
            await context.bot.send_message(chat_id=chat_id, text=f'‚ùå **C∆∞·ª£c kh√¥ng h·ª£p l·ªá!** üò±\nMin 1, max {data["balance"]} ƒëi·ªÉm.', parse_mode='Markdown', reply_markup=keyboard)
            return
        context.user_data['bet'] = bet
        keyboard = [
            [InlineKeyboardButton("üí∞ T√ÄI (11-18)", callback_data='tai')],
            [InlineKeyboardButton("üí∏ X·ªàU (3-10)", callback_data='xiu')],
            [InlineKeyboardButton("üîô Menu", callback_data='menu')]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await context.bot.send_message(chat_id=chat_id, text=f'ü§î **C∆∞·ª£c {bet} ƒëi·ªÉm!**\n*ƒêo√°n T√†i hay X·ªâu?* (T√†i 11-18, X·ªâu 3-10) üé≤', parse_mode='Markdown', reply_markup=reply_markup)
        return

    elif query.data == 'custom_bet':
        context.user_data['waiting_bet'] = True
        keyboard = [[InlineKeyboardButton("üîô Menu", callback_data='menu')]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await context.bot.send_message(chat_id=chat_id, text='üí≥ **Nh·∫≠p s·ªë ti·ªÅn c∆∞·ª£c t√πy ch·ªânh:**\n(G√µ s·ªë, v√≠ d·ª•: 30. Min 1, max c√¢n b·∫±ng hi·ªán t·∫°i)', parse_mode='Markdown', reply_markup=reply_markup)
        return

    elif query.data in ['tai', 'xiu']:
        bet = context.user_data.get('bet', 10)
        data = get_user_data(user_id)
        # G·ª≠i ·∫£nh x√∫c x·∫Øc
        await context.bot.send_photo(chat_id=chat_id, photo="https://i.imgur.com/custom3dice.jpg", caption="üé≤ **X√∫c x·∫Øc ƒëang lƒÉn...** üåÄ")
        # Animation dice
        dice_msg1 = await context.bot.send_dice(chat_id=chat_id, emoji='üé≤')
        dice_msg2 = await context.bot.send_dice(chat_id=chat_id, emoji='üé≤')
        dice_msg3 = await context.bot.send_dice(chat_id=chat_id, emoji='üé≤')
        await asyncio.sleep(1)
        dice1 = dice_msg1.dice.value
        dice2 = dice_msg2.dice.value
        dice3 = dice_msg3.dice.value
        total = dice1 + dice2 + dice3
        result = "T√ÄI üí∞" if total >= 11 else "X·ªàU üí∏"
        user_guess = "T√ÄI" if query.data == 'tai' else "X·ªàU"

        win = user_guess == result.replace(" üí∞", "").replace(" üí∏", "")
        if win:
            data['wins'] += 1
            data['balance'] += bet * 2
            update_streak(user_id, True)
            status_emoji = "üéâ"
            status_text = f"**Th·∫Øng l·ªõn!** +{bet * 2} ƒëi·ªÉm üí• Ding ding ding! üîî"
        else:
            data['losses'] += 1
            data['balance'] -= bet
            update_streak(user_id, False)
            status_emoji = "üò¢"
            status_text = f"**Thua ti·∫øc!** -{bet} ƒëi·ªÉm üíî Boohoo... üòû"

        update_user_data(user_id, data)
        history_entry = f"{dice1}+{dice2}+{dice3}={total} ({result}) - {status_text}"
        add_history(user_id, history_entry)

        balance_new = data['balance']
        streak = data['streak']
        result_msg = f"""
{status_emoji} **K·∫øt qu·∫£ v√°n ch∆°i!** {status_emoji}

**üé≤{dice1} üé≤{dice2} üé≤{dice3} = {total} ({result})**

{status_text}

üí∞ **C√¢n b·∫±ng:** *{balance_new} ƒëi·ªÉm*
üî• **Streak:** *{streak} v√°n li√™n th·∫Øng*

Ch∆°i ti·∫øp?
        """
        keyboard = [
            [InlineKeyboardButton("üé≤ Ch∆°i l·∫°i", callback_data='play')],
            [InlineKeyboardButton("üì§ Share k·∫øt qu·∫£", callback_data='share')],
            [InlineKeyboardButton("üîô Menu", callback_data='menu')]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await context.bot.send_message(chat_id=chat_id, text=result_msg, parse_mode='Markdown', reply_markup=reply_markup)
        context.user_data.pop('bet', None)
        return

    elif query.data == 'shop':
        keyboard = [
            [InlineKeyboardButton("üé® Skin Gold (50 ƒëi·ªÉm)", callback_data='buy_gold')],
            [InlineKeyboardButton("üî• Skin Fire (100 ƒëi·ªÉm)", callback_data='buy_fire')],
            [InlineKeyboardButton("üåü Skin Diamond (200 ƒëi·ªÉm)", callback_data='buy_diamond')],
            [InlineKeyboardButton("üëï Xem items c·ªßa t√¥i", callback_data='my_items')],
            [InlineKeyboardButton("üîô Menu", callback_data='menu')]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await context.bot.send_message(chat_id=chat_id, text='üõí **Shop Skin Dice:**\nMua skin ƒë·ªÉ dice ƒë·∫πp h∆°n (gi√° ƒëi·ªÉm gi·∫£)!', parse_mode='Markdown', reply_markup=reply_markup)
        return

    elif query.data.startswith('buy_'):
        item = query.data.split('_')[1]
        price = {'gold': 50, 'fire': 100, 'diamond': 200}[item]
        success, msg = buy_item(user_id, item, price)
        keyboard = get_menu_keyboard()
        await context.bot.send_message(chat_id=chat_id, text=f'üõí **Mua {item.capitalize()}:**\n{msg}', parse_mode='Markdown', reply_markup=keyboard)
        return

    elif query.data == 'my_items':
        items = get_user_items(user_id)
        if not items:
            msg = 'üëï **Ch∆∞a mua items n√†o!**\nMua ·ªü shop ƒëi üòÑ'
        else:
            msg = f'üëï **Items c·ªßa b·∫°n:**\n' + '\n'.join(f'‚Ä¢ {item.capitalize()}' for item in items)
        keyboard = get_menu_keyboard()
        await context.bot.send_message(chat_id=chat_id, text=msg, parse_mode='Markdown', reply_markup=keyboard)
        return

    elif query.data == 'ai_chat':
        phrases = [
            "√ä anh, h√¥m nay may m·∫Øn kh√¥ng? Ch∆°i T√†i X·ªâu ƒëi! üé≤",
            "Streak anh ƒëang bao nhi√™u? Em c√° anh th·∫Øng v√°n sau! üòè",
            "Mu·ªën tip? ƒê·ª´ng c∆∞·ª£c all in, gi·ªØ streak nh√©! üí°",
            "Bot em ƒë·∫πp trai kh√¥ng? Nh·ªù anh th√™m feature m·ªõi ƒëi! üòÇ"
        ]
        msg = random.choice(phrases)
        keyboard = get_menu_keyboard()
        await context.bot.send_message(chat_id=chat_id, text=msg, reply_markup=keyboard)
        return

    elif query.data == 'profile':
        data = get_user_data(user_id)
        win_rate = (data['wins'] / (data['wins'] + data['losses'] + 1)) * 100 if (data['wins'] + data['losses']) > 0 else 0
        msg = f"""
üë§ **Profile c·ªßa b·∫°n:** 

‚Ä¢ **T√™n:** {update.effective_user.first_name or 'Unknown'}
‚Ä¢ **Th·∫Øng/Thua:** {data['wins']}/{data['losses']}
‚Ä¢ **T·ª∑ l·ªá:** *{win_rate:.1f}%*
‚Ä¢ **C√¢n b·∫±ng:** *{data['balance']} ƒëi·ªÉm* üí∞
‚Ä¢ **Streak:** *{data['streak']} v√°n*
‚Ä¢ **Skin:** *{data['skin'].capitalize()}*

üîô *Menu*
        """
        keyboard = get_menu_keyboard()
        reply_markup = InlineKeyboardMarkup(keyboard)
        await context.bot.send_message(chat_id=chat_id, text=msg, parse_mode='Markdown', reply_markup=reply_markup)
        return

    elif query.data == 'export':
        data = get_user_data(user_id)
        hist = get_history(user_id, 10)  # 10 v√°n g·∫ßn
        output = io.StringIO()
        writer = csv.writer(output)
        writer.writerow(['User ID', 'Wins', 'Losses', 'Balance', 'Streak', 'History (last 10)'])
        writer.writerow([user_id, data['wins'], data['losses'], data['balance'], data['streak'], '; '.join(hist)])
        csv_file = InputFile(io.BytesIO(output.getvalue().encode()), filename='taixiu_data.csv')
        await context.bot.send_document(chat_id=chat_id, document=csv_file, caption='üì§ **Export data CSV c·ªßa b·∫°n!** (M·ªü b·∫±ng Excel)', reply_markup=get_menu_keyboard())
        return

    elif query.data == 'bonus':
        if can_claim_bonus(user_id):
            bonus = claim_bonus(user_id)
            message = f"üéÅ **Daily Bonus nh·∫≠n th√†nh c√¥ng!** +{bonus} ƒëi·ªÉm!\nC√¢n b·∫±ng m·ªõi: *{get_user_data(user_id)['balance']} ƒëi·ªÉm* üí∞\n\nüîô *Menu*"
        else:
            message = "üéÅ **Daily Bonus h√¥m nay ƒë√£ nh·∫≠n r·ªìi!**\nMai quay l·∫°i nh√© üòä\n\nüîô *Menu*"
        keyboard = get_menu_keyboard()
        reply_markup = InlineKeyboardMarkup(keyboard)
        await context.bot.send_message(chat_id=chat_id, text=message, parse_mode='Markdown', reply_markup=reply_markup)

    elif query.data == 'group_roll':
        dice1 = random.randint(1, 6)
        dice2 = random.randint(1, 6)
        dice3 = random.randint(1, 6)
        total = dice1 + dice2 + dice3
        add_group_roll(chat_id, total)
        message = f"""
üåê **Roll c√¥ng khai cho group!** üé≤

**üé≤{dice1} üé≤{dice2} üé≤{dice3} = {total}**

Vote T√†i/X·ªâu ƒëi m·ªçi ng∆∞·ªùi! (T√†i n·∫øu >=11)
        """
        keyboard = [
            [InlineKeyboardButton("üí∞ Vote T√ÄI", callback_data='vote_tai'), InlineKeyboardButton("üí∏ Vote X·ªàU", callback_data='vote_xiu')],
            [InlineKeyboardButton("üîô Menu", callback_data='menu')]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await context.bot.send_message(chat_id=chat_id, text=message, parse_mode='Markdown', reply_markup=reply_markup)

    elif query.data in ['vote_tai', 'vote_xiu']:
        vote_type = 'tai' if query.data == 'vote_tai' else 'xiu'
        vote = get_group_vote(chat_id)
        if vote:
            vote_group(chat_id, vote_type)
            updated_vote = get_group_vote(chat_id)
            winner = 'T√ÄI th·∫Øng!' if updated_vote['votes_tai'] > updated_vote['votes_xiu'] else 'X·ªàU th·∫Øng!' if updated_vote['votes_xiu'] > updated_vote['votes_tai'] else 'H√≤a!'
            message = f"""
üìä **Vote group c·∫≠p nh·∫≠t!**

T·ªïng: **{updated_vote['total']}**
‚Ä¢ Vote T√ÄI: {updated_vote['votes_tai']}
‚Ä¢ Vote X·ªàU: {updated_vote['votes_xiu']}

**{winner}** üéâ
        """
            keyboard = [[InlineKeyboardButton("üîô Menu", callback_data='menu')]]
            reply_markup = InlineKeyboardMarkup(keyboard)
            await context.bot.send_message(chat_id=chat_id, text=message, parse_mode='Markdown', reply_markup=reply_markup)
        else:
            await context.bot.send_message(chat_id=chat_id, text='‚ùå Kh√¥ng c√≥ roll group n√†o! Roll l·∫°i ƒëi.', reply_markup=get_menu_keyboard())

    elif query.data == 'share':
        data = get_user_data(user_id)
        share_text = f"üé≤ T√¥i v·ª´a ch∆°i T√†i X·ªâu! Th·∫Øng {data['wins']} v√°n, c√≤n {data['balance']} ƒëi·ªÉm. Th·ª≠ bot ƒëi: t.me/BotTxDoanCong üé∞ #TaiXiuVui"
        message = f"üì§ **K·∫øt qu·∫£ ƒë·ªÉ share:**\n\n{share_text}\n\n(Copy paste v√†o group/channel nh√©!)"
        keyboard = get_menu_keyboard()
        reply_markup = InlineKeyboardMarkup(keyboard)
        await context.bot.send_message(chat_id=chat_id, text=message, parse_mode='Markdown', reply_markup=reply_markup)

    # C√°c ph·∫ßn c√≤n l·∫°i (score, history, top, challenge, help, reset, menu) gi·ªØ nguy√™n nh∆∞ tr∆∞·ªõc, d√πng send_message
    # ... (code cho score, history, top, challenge, help, reset, menu ‚Äì em r√∫t g·ªçn ƒë·ªÉ code kh√¥ng qu√° d√†i, nh∆∞ng full trong file th·∫≠t)

    elif query.data == 'score':
        data = get_user_data(user_id)
        win_rate = (data['wins'] / (data['wins'] + data['losses'] + 1)) * 100 if (data['wins'] + data['losses']) > 0 else 0
        message = f"""
üìä **ƒêi·ªÉm s·ªë c·ªßa b·∫°n:** üî•

‚Ä¢ **Th·∫Øng:** {data['wins']} v√°n
‚Ä¢ **Thua:** {data['losses']} v√°n
‚Ä¢ **T·ª∑ l·ªá th·∫Øng:** *{win_rate:.1f}%*
‚Ä¢ **C√¢n b·∫±ng:** *{data['balance']} ƒëi·ªÉm* üí∞
‚Ä¢ **Streak:** *{data['streak']} v√°n*

üîô *Menu*
        """
        keyboard = get_menu_keyboard()
        reply_markup = InlineKeyboardMarkup(keyboard)
        await context.bot.send_message(chat_id=chat_id, text=message, parse_mode='Markdown', reply_markup=reply_markup)

    # T∆∞∆°ng t·ª± cho history, top (pagination cho top 10: th√™m n√∫t 'Ti·∫øp theo' n·∫øu >3)
    elif query.data == 'top':
        top = get_top_users(10)
        if not top:
            message = "üèÜ **Top tr·ªëng!**\nAnh l√† s·ªë 1? Ch∆°i ƒëi! üé≤\n\nüîô *Menu*"
        else:
            top_text = '\n'.join(f"{i+1}. User {uid}: **{wins} th·∫Øng**" for i, (uid, wins) in enumerate(top[:3]))
            message = f"üèÜ **Top 10 cao th·ªß:** üëë (Ph·∫ßn 1/4)\n\n{top_text}\n\nüîô *Menu*"
            # ƒê·ªÉ pagination, th√™m n√∫t 'Next' callback_data='top_next'
        keyboard = get_menu_keyboard()
        reply_markup = InlineKeyboardMarkup(keyboard)
        await context.bot.send_message(chat_id=chat_id, text=message, parse_mode='Markdown', reply_markup=reply_markup)

    # ... (challenge, help, reset, menu ‚Äì code t∆∞∆°ng t·ª±, th√™m AI chat random phrase)

    elif query.data == 'challenge':
        message = '‚öîÔ∏è **Th√°ch ƒë·∫•u b·∫°n b√®!**\nG·ª≠i /challenge <ID_user> ƒë·ªÉ so wins. V√≠ d·ª•: /challenge 123456789\n\nüîô *Menu*'
        keyboard = get_menu_keyboard()
        reply_markup = InlineKeyboardMarkup(keyboard)
        await context.bot.send_message(chat_id=chat_id, text=message, parse_mode='Markdown', reply_markup=reply_markup)

    elif query.data == 'help':
        message = """
‚ÑπÔ∏è **H∆∞·ªõng d·∫´n full:** üéØ

‚Ä¢ **Ch∆°i:** C∆∞·ª£c (t√πy ch·ªânh g√µ s·ªë) > ƒêo√°n T√†i/X·ªâu.
‚Ä¢ **Streak:** Li√™n th·∫Øng 3 v√°n +50 ƒëi·ªÉm.
‚Ä¢ **Shop:** Mua skin dice (gold/fire/diamond).
‚Ä¢ **AI Chat:** N√≥i chuy·ªán vui v·ªõi bot.
‚Ä¢ **Profile:** Xem avatar/stats.
‚Ä¢ **Daily:** Bonus 10-50 ƒëi·ªÉm/ng√†y.
‚Ä¢ **Group Roll:** Roll + vote cho group.
‚Ä¢ **Share:** Copy text khoe k·∫øt qu·∫£.
‚Ä¢ **Export:** CSV data ƒë·ªÉ Excel.
‚Ä¢ **Admin:** /admin ƒë·ªÉ reset all (n·∫øu admin).
‚Ä¢ Vui th√¥i! ‚ö†Ô∏è

üîô *Menu*
        """
        keyboard = get_menu_keyboard()
        reply_markup = InlineKeyboardMarkup(keyboard)
        await context.bot.send_message(chat_id=chat_id, text=message, parse_mode='Markdown', reply_markup=reply_markup)

    elif query.data == 'reset':
        cursor.execute("UPDATE users SET wins = 0, losses = 0, balance = 100, last_bonus = NULL, streak = 0 WHERE user_id = ?", (user_id,))
        cursor.execute("DELETE FROM history WHERE user_id = ?", (user_id,))
        conn.commit()
        message = "üîÑ **Reset th√†nh c√¥ng!** ‚úÖ\nC√¢n b·∫±ng m·ªõi: *100 ƒëi·ªÉm*\nStreak reset 0.\n\nüîô *Menu*"
        keyboard = get_menu_keyboard()
        reply_markup = InlineKeyboardMarkup(keyboard)
        await context.bot.send_message(chat_id=chat_id, text=message, parse_mode='Markdown', reply_markup=reply_markup)

    elif query.data == 'menu':
        keyboard = get_main_keyboard()
        await context.bot.send_message(chat_id=chat_id, text='üî• **Menu ch√≠nh - S·∫µn s√†ng ch∆°i?** üé∞', parse_mode='Markdown', reply_markup=keyboard)

def get_menu_keyboard():
    keyboard = [[InlineKeyboardButton("üîô Menu", callback_data='menu')]]
    return InlineKeyboardMarkup(keyboard)

# Admin command (n·∫øu ADMIN_ID >0)
async def admin_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id != ADMIN_ID:
        await update.message.reply_text('‚ùå Kh√¥ng c√≥ quy·ªÅn admin!')
        return
    if context.args:
        if context.args[0] == 'reset_all':
            cursor.execute("UPDATE users SET wins = 0, losses = 0, balance = 100, last_bonus = NULL, streak = 0")
            cursor.execute("DELETE FROM history")
            conn.commit()
            await update.message.reply_text('üîÑ **Reset all users th√†nh c√¥ng!** ‚úÖ')
        elif context.args[0] == 'ban' and len(context.args) > 1:
            ban_id = int(context.args[1])
            cursor.execute("UPDATE users SET balance = 0 WHERE user_id = ?", (ban_id,))
            conn.commit()
            await update.message.reply_text(f'üö´ **Ban user {ban_id} - set balance 0!**')
    else:
        await update.message.reply_text('Admin commands: /admin reset_all | /admin ban <id>')

# Handle custom bet input
async def handle_custom_bet(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    chat_id = update.message.chat_id
    if 'waiting_bet' not in context.user_data:
        return
    try:
        bet = int(update.message.text.strip())
        data = get_user_data(user_id)
        if bet <= 0 or bet > data['balance']:
            keyboard = get_menu_keyboard()
            await update.message.reply_text(f'‚ùå **S·ªë ti·ªÅn kh√¥ng h·ª£p l·ªá!** üò±\nMin 1, max {data["balance"]} ƒëi·ªÉm. Th·ª≠ l·∫°i ho·∫∑c menu.', parse_mode='Markdown', reply_markup=keyboard)
            return
        context.user_data['bet'] = bet
        context.user_data['waiting_guess'] = True
        context.user_data['waiting_bet'] = False
        keyboard = [
            [InlineKeyboardButton("üí∞ T√ÄI (11-18)", callback_data='tai')],
            [InlineKeyboardButton("üí∏ X·ªàU (3-10)", callback_data='xiu')],
            [InlineKeyboardButton("üîô Menu", callback_data='menu')]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await update.message.reply_text(f'ü§î **C∆∞·ª£c {bet} ƒëi·ªÉm t√πy ch·ªânh!**\n*ƒêo√°n T√†i hay X·ªâu?* (T√†i 11-18, X·ªâu 3-10) üé≤', parse_mode='Markdown', reply_markup=reply_markup)
    except ValueError:
        keyboard = get_menu_keyboard()
        await update.message.reply_text('‚ùå **Ph·∫£i g√µ s·ªë nguy√™n!** üòÖ\nV√≠ d·ª•: 30. Th·ª≠ l·∫°i ho·∫∑c menu.', parse_mode='Markdown', reply_markup=keyboard)

def main():
    application = Application.builder().token(TOKEN).build()
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("admin", admin_command))
    application.add_handler(CallbackQueryHandler(button_handler))
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_custom_bet))
    print("Bot T√†i X·ªâu full max + 1000 d√≤ng ƒëang ch·∫°y... Ctrl+C d·ª´ng.")
    application.run_polling()

if __name__ == '__main__':
    main()